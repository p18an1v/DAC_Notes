#include<iostream>
// in the following example,
// unique_ptr (one of the smart pointers) 
// is an inbuilt class template.
// it maintains a pointer internally which
// points to your "new int(10)" memory of 
// heap area. 
// Here advantage is that as soon as "p" goes
// out of scope ,its destructor gets called
// which releases the memory "new int(10)"
// so you don't have to bother about releasing
// it explicitly.
using namespace std;
void fun(int val)
{
	unique_ptr<int> p(new int(10));
	if (val <= 0)
	{
		return;
	}
	unique_ptr<int> p1;
	p1= p; // error // the raw pointer 
	// inside "p" points to memory block from
	// heap area, that same memory block cannot
	// be pointed to by another raw pointer
	// from "p1". operator= is marked as private in unique_ptr.
	// thus unique_ptr ensures that a memory
	// block from heap area can be pointed to
	// by only one raw pointer at a time.
	cout << "done with fun" << endl;
}
int main()
{
	fun(10);
	// fun(-10); // what will happen here?
}