#include<iostream>
// in the following example,
// unique_ptr (one of the smart pointers) 
// is an inbuilt class template.
// it maintains a pointer internally which
// points to your "new int(10)" memory of 
// heap area. 
// Here advantage is that as soon as "p" goes
// out of scope ,its destructor gets called
// which releases the memory "new int(10)"
// so you don't have to bother about releasing
// it explicitly.
using namespace std;
void fun(int val)
{
	unique_ptr<int> p(new int(10));
	if (val <= 0)
	{
		return;
	}
	cout <<"contents of p is\t"<< * p << endl;
	//p->  // In the case of unique_ptr<int> 
	// p(new int(10)), p is a pointer to an 
	// int, not a pointer to a class with 
	// member functions. So, using the -> 
	// operator directly on p isn't applicable
	// because p doesn't have any members 
	//to access.
	cout << "done with fun" << endl;
}
int main()
{
	fun(10);
	// fun(-10); // what will happen here?
}